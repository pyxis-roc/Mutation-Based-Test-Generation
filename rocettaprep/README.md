# ROCetta Prep Tools

These tools prepare the ROCetta instruction semantics for use by the
mutation testing tools.

A brief overview of each tool is given, along with hints on how to
potentially adapt the tools to other instruction sets.

## `setup_workdir.py`

All data for the experiments are stored in a single working
directory. This script sets that directory up. In particular, it
creates a file `params.json` that stores common inputs to all the
scripts that follow.

## `build_single_instruction.py`

Given a C file where each function represents the semantics of a
single instruction (`ptxc.c`) and a collection of unit tests from
ROCetta PTX semantics project directory (`v6.5/c/.c`), the
`build_single_instruction.py` script first creates an instruction
working directory. It then extracts the semantic function into a
standalone file in that working directory (e.g.,`add_f32_fn.c`), and
copies the unit test into that directory, creating the _oracle_ for
the instruction.

## `build_mutations.py`

For each instruction whose semantics have been extracted, the
`build_mutations.py` script invokes the mutator (here, MUSIC) on the
standalone semantics file. The resulting mutations are stored in the
`music` subdirectory inside each instruction's working directory.

## `build_test_info.py`

The `build_test_info.py` script sets up JSON files with paths to the
text files containing the inputs used by the unit tests. Initially,
there are only the files containing the inputs generated by the
stratified sampler. As the framework runs, files generated by the
equivalence checker and the fuzzers are also added to the JSON files.

## `build_eqvcheck_driver.py`

For each mutant generated by `build_mutations.py`, a driver that
compares the behaviour of the mutated function and the original
function is created by `build_eqvcheck_driver.py`. These driver is
placed in the `eqchk` subdirectory accompanied by files containing the
original and one of the mutated versions of the semantics.

## `build_fuzzer_driver.py`

Similarly, for each mutant, a driver conforming to `libfuzzer`
specifications is generated by `build_fuzzer_driver.py`. Two possible
drivers can be created, a simple one that leaves it up to libfuzzer to
generate and explore the input space, and a custom one that uses
stratified sampling. The code here has much in common with
`build_eqvcheck_driver.py` but is duplicated to minimize coupling.

## `build_binaries.py`

Rather than compile binaries for the oracles and mutants on the fly,
the `build_binaries.py` script precompiles them, and also generates
the expected output from the oracle for the inputs generated by the
stratified sampler. Moreover, it saves the output of the compilation
for each mutant for use by the `explain.py` script.

## `run_expt.py`

The overarching script to orchestrate the execution of experiments and
collection of data, `run_expt.py` runs a large number of scripts:

  - `run_mutants_2.py`, to run each mutant on a chosen set of inputs.
  - `run_eqvcheck_2.py`, to run the equivalence checker on each mutant
  - `run_gather_witnesses.py` to extract the inputs/outputs generated by the equivalence checker
  - `run_fuzzer_2.py`, to run the fuzzers on each mutant
  - `run_collect_fuzzer.py`, to collect the inputs generated by each
    fuzzer and generate the expected output using the oracle
  - `stats_mutants.py`, to gather statistics on mutants per instruction
  - `stats_survivors.py`, to gather statistics on survivors
  - `stats_inputs.py`, to gather statistics on number of inputs generated
  - `stats_timing.py`, to gather timing statistics
  - `run_oracle.py`, to check if the oracle can pass all generated inputs

Many of these scripts are independent of the exact instruction set
used and can probably be repurposed easily.

## `paper_results.sh`

The `paper_results.sh` processes the statistics obtained from
`run_expt.py` using 3 scripts to generate the tables used in the paper:

  - `gen_pipeline.py`, summarizes results on mutants flowing through the test generation pipeline
  - `gen_inputs.py`, summarizes results on inputs generated
  - `results_timing.py`, summarizes timing results.

## `explain.py`

This `explain.py` script can be used to examine the results from the
test generation pipeline for each instruction. This is most useful
when mutants are killed by the equivalence checker, but not by the
fuzzer, for example.

## `setup_insn_info.py` and `insninfo.py`

Each instruction's semantics is encoded as a C function. To generate
test harnesses for the equivalence checker and fuzzers, information
about the inputs and outputs for instruction are provided in the
`insninfo.py` file that is automatically generated by
`setup_insn_info.py`. The script uses an internal database from the
ROCetta project. For the vast majority of functions, the schema is
self-explanatory describing the types and input, output and
input/output arguments. For some PTX instructions, such as `lop` which
have varied syntactic forms, but a single semantics, there is a layer
of indirection from the syntactc form to the base instruction.


